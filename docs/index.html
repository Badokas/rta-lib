<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rta-lib: rta-lib overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rta-lib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">rta-lib overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>WORK IN PROGRESS !!!</h1>
<h1>Table of Contents</h1>
<ul>
<li>1 <a href="#generalities">Generalities</a></li>
<li>2 <a href="#configuration">Library configuration</a></li>
<li>3 <a href="#descr_vector_samples">Descriptors based on a vector of samples</a><ul>
<li>3.1 <a href="#resampling">Re-sampling</a></li>
<li>3.2 <a href="#yin">Yin</a></li>
<li>3.3 <a href="#gain_integer_float">Gain and integer-float conversion</a></li>
<li>3.4 <a href="#pre_emphasis">Pre-emphasis</a></li>
<li>3.5 <a href="#windowing">Windowing</a></li>
<li>3.6 <a href="#lpc">Linear predictive coefficients (LPC)</a></li>
</ul>
</li>
<li>4 <a href="#descr_power_spectrum">Descriptors based on the power spectrum</a><ul>
<li>4.1 <a href="#real_fourier_transform">Real Fourier transform</a></li>
<li>4.2 <a href="#complex_to_power_spectrum">Complex spectrum to power spectrum</a></li>
<li>4.3 <a href="#statistical_moments">Statistical moments</a><ul>
<li>4.3.1 <a href="#centroid">Centroid</a></li>
<li>4.3.2 <a href="#spread_deviation">Spread and deviation</a></li>
<li>4.3.3 <a href="#skewness">Skewness</a></li>
<li>4.3.4 <a href="#kurtosis">Kurtosis</a></li>
</ul>
</li>
</ul>
</li>
<li>5 <a href="#descr_mel_bands">Descriptors based on the mel bands</a><ul>
<li>5.1 <a href="#mel_bands">Mel bands</a></li>
<li>5.2 <a href="#mfcc">Mel-frequency cepstral coefficients (MFCC)</a></li>
<li>5.3 <a href="#delta_delta_mfcc">Delta and delta-delta MFCC</a> -6 <a href="#style_guide">Style guide</a></li>
<li>6.1 <a href="#prefix">Prefix</a></li>
<li>6.2 <a href="#declarations_definitions">Declarations and definitions</a></li>
<li>6.3 <a href="#headers">Headers</a></li>
<li>6.4 <a href="#real_types">Real types</a></li>
<li>6.5 <a href="#memory_allocation">Memory allocation</a></li>
</ul>
</li>
</ul>
<p><a class="anchor" id="generalities"></a> </p><h1>1 Generalities</h1>
<p>The <em>RTA</em> library is frame-based, which means that for any vectors of samples, a set of descriptors can be computed without adding any delay. A noticeable exception to this is the <em>delta</em> (and <em>delta-delta</em>) computation, as it is based on more than one frame.</p>
<p>There are two variants of each function, one being <b>_stride</b> post-fixed. It allows to directly access interleaved data without copying them (like a stereophonic samples vector). However, using a big <em>stride</em> value may lead to a bad usage of the memory cache.</p>
<p>Any index starts at 0.</p>
<p>Some functions require an initialisation before any processing, in order to pre-calculate what will not depend on the incoming frame. Every allocation must be done before anything else, outside of the functions themselves except mentioned otherwise.</p>
<p>Some descriptors can be computed by several functions, and the results may slightly differ for several reasons: the functions does not rely on the same algorithms and the signal used for the computation may differ (due to windowing, filtering, etc.). The auto-correlation from <em>yin</em> and from the <em>LPC</em> are not the same and there is a lot of ways to get the energy: from <em>yin</em>, as the sum of the squares of the samples, from <em>LPC</em>, or as the first <em>MFCC</em> coefficient.</p>
<p><a class="anchor" id="configuration"></a> </p><h1>2 Library configuration</h1>
<p>A file named <b>rta_configuration.h</b> must be present within your sources in order to use the <em>RTA</em> library. It is not included within the <em>RTA</em> source files. An empty file means that the defaults settings are used for the compilation.</p>
<p>Instead of using the <b>malloc</b>, <b>realloc</b> and <b>free</b> functions from the <b>stdlib.h</b>, one can respectively define <b>rta_malloc</b>, <b>rta_realloc</b> and <b>rta_free</b>. (see <a href="#memory_allocation">6.5</a>)</p>
<p>The floating-point precision can be simple, double or long double, according to the definition of <b>RTA_REAL_TYPE</b> to respectively <b>RTA_FLOAT_TYPE</b>, <b>RTA_DOUBLE_TYPE</b> or <b>RTA_LONG_DOUBLE_TYPE</b>. The constants in <b><a class="el" href="rta__float_8h.html" title="rta_real_t type wrapper for &lt;float.h&gt; ">rta_float.h</a></b> are then redefined according to the proper type from <b>float.h</b>. The same applies to the functions in <b><a class="el" href="rta__math_8h.html" title="Mathematical functions, &lt;math.h&gt; for rta_real_t type. ">rta_math.h</a></b> from <b>math.h</b>. (see <a href="#real_types">6.4</a>)</p>
<p>Note that the long double precision is not supported when using the Apple's VecLib by setting <b>RTA_USE_VECLIB</b> to 1.</p>
<p><a class="anchor" id="descr_vector_samples"></a> </p><h1>3 Descriptors based on a vector of samples</h1>
<p>The vector of samples is characterised by its sample-rate and its size. Moreover, to use sizes larger than those provided by the sound card (e.g. for Fourier transforms), the hop-size gives the number of samples between two consecutive vectors that overlap if the hop-size is smaller than the vector-size.</p>
<p><a class="anchor" id="resampling"></a> </p><h2>3.1 Re-sampling</h2>
<p>Down-sampling a signal is interesting to lower the further computations, especially for the computational-intensive algorithms, like <em>yin</em>. It can helps to concentrate on a range of the spectrum where the information is pertinent for the analysis: the <em>LPC</em> (which is linear, as its name suggests it) finds poles and zeros to fit the whole spectrum; to keep the results under 5 kHz, we simply use a sample-rate of 11 kHz. If the original signal sample-rate is 44 kHz, we can use the function <b>rta_downsample_int_mean</b> with a factor of 4. This function implies a low-pass filtering. The function <b>rta_downsample_int_remove</b> can produce aliasing if the original signal contains information above half of the resulting sample-rate. Note that the resulting samples vector-size is smaller, according to the given factor.</p>
<p><a class="anchor" id="yin"></a> </p><h2>3.2 Yin</h2>
<p>The <em>yin</em> algorithm computes the periodicity of a samples vector, finding its most probable <em>lag</em>. To get the period in Hz, on simply multiply this lag by the input vector sample-rate.</p>
<p>Note that the <em>yin</em> algorithm operates on a non-windowed samples vector. As it can be computational-intensive, a down-sampling of the incoming vector is often performed: to track a pitch below 1 kHz, one can use a sampling-rate of 11 kHz, or even 5.5 kHz, depending on the results quality request. One can then check the <em>absolute minimum</em> found, which gives the <em>periodicity</em> as long as the absolute minimum is positive:</p>
<p>Before computing anything, a new <em>yin</em> structure must be allocated and filled with the <b>rta_yin_setup_new</b> function. It will be released by the function <b>rta_yin_setup_delete</b>. (The auto-correlation result vector must also be allocated beforehand, like any results vector.)</p>
<p><a class="anchor" id="gain_integer_float"></a> </p><h2>3.3 Gain and integer-float conversion</h2>
<p>The samples are generally coded by floating-points number over 32 bits, within the range [-1.0, 1.0]. To convert them into 16 bits signed integers (which is the format used by some systems, like <em>HTK</em>), one can apply a simple gain of by multiplying every sample.</p>
<p><a class="anchor" id="pre_emphasis"></a> </p><h2>3.4 Pre-emphasis</h2>
<p>The pre-emphasis is a simple first-order difference between a current sample and the previous one (weighted by a factor):</p>
<p>It is often used for voice analysis with a factor of 0.97 as it reduces the low frequencies while raising the high frequencies, thus amplifying the contrast.</p>
<p><a class="anchor" id="windowing"></a> </p><h2>3.5 Windowing</h2>
<p>If the samples vector-size is known, it is possible to pre-calculate the weights that will be used to apply a given function. The function <b>rta_window_hamming_weights</b> computes a <em>Hamming</em> window while the function <b>rta_window_hann_weights</b> computes a <em>von Hann</em> window. These (or any weights vector) can be applied with the <b>rta_window_apply</b> function. The <b>_in_place</b> post-fixed functions change the input samples vector values directly.</p>
<p>If the samples vector-size is not known in advance, one can still apply the window using the <b>rta_window_rounded_apply</b> function. There is no interpolation, then. The weights vector indexes are simply scaled and rounded: this is efficient but the rounding error may be unacceptable if the size of the weights vector is too small comparing with the samples vector size. It is also possible to compute and apply a window on the fly, with the functions <b>rta_window_hann_apply</b> and <b>rta_window_hamming_apply</b>.</p>
<p><a class="anchor" id="lpc"></a> </p><h2>3.6 Linear predictive coefficients (LPC)</h2>
<p>The <b>rta_lpc</b> function calculates the linear predictive coefficients (<em>LPC</em>) for a samples vector, using an auto-correlation and a <em>Levinson-Durbin</em> decomposition. Note that the <em>LPC</em> order is one value less than the <em>LPC</em> size.</p>
<p>The first <em>LPC</em> coefficient is always 1 and is often replaced (e.g. in <em>HTK</em>) by the prediction error, which gives the energy of the samples vector. If the <em>LPC</em> is computed on overlapping samples vectors, they are often windowed in order for the coefficients to evolve smoothly from frame to frame, and the energy is then reduced (by a constant factor depending on the window).</p>
<p><a class="anchor" id="descr_power_spectrum"></a> </p><h1>4 Descriptors based on the power spectrum</h1>
<p>Some descriptors are based on the power spectrum of a samples vector. The samples vector is first windowed. Then a real <em>Fourier</em> transform is applied, giving a complex spectrum. The power spectrum is the square of the magnitude of the complex spectrum.</p>
<p><a class="anchor" id="real_fourier_transform"></a> </p><h2>4.1 Real Fourier transform</h2>
<p>Before computing a real <em>Fourier</em> transform, a new real <em>Fourier</em> transform setup must be allocated and filled with the <b>rta_fft_real_setup_new</b> function, with the type <b>real_to_complex_1d</b>. It will be released by the function <b>rta_fft_setup_delete</b>. The function <b>rta_fft_execute</b> applies the <em>Fourier</em> transform to a samples vector.</p>
<p>The transform size must be a power of 2. If the transform size is bigger than the actual samples vector, it is then padded with zeros.</p>
<p>By convention (e.g. <em>HTK</em>), no scale is applied to this direct transform. The inverse of the transform size can later be applied to the inverse transform in order to obtain the identity transform.</p>
<p><a class="anchor" id="complex_to_power_spectrum"></a> </p><h2>4.2 Complex spectrum to power spectrum</h2>
<p>The power spectrum is the square of the magnitude the complex spectrum.</p>
<p>Its size is half the size of the <em>Fourier</em> transform plus one (the last element corresponds to the <em>Nyquist</em> frequency). To get a correspondence between the power spectrum index and the corresponding frequency, one can apply a simple ratio between the maximum frequency (which is half of the sample-rate) and the maximum index (which is half of the <em>Fourier</em> transform size, as all the indexes start at 0):</p>
<p><a class="anchor" id="statistical_moments"></a> </p><h2>4.3 Statistical moments</h2>
<p>The statistical moments can be computed from any samples vector, as long as the weights are positive, as they represent the probability of the random variables to appear. The power spectrum conforms to this, as any value is positive, but not the amplitude spectrum (if not translated above 0). The same applies for the moments of the mel bands.</p>
<p>The moments are calculated over the indexes and weighted by the input values. They will be normalised by the sum of the input values in order to get the indexes probability. Note that all moments (but the first) are centred. Any moment above the second can be standardised.</p>
<p>The moments described hereafter describe the power spectrum moments.</p>
<p><a class="anchor" id="centroid"></a> </p><h3>4.3.1 Centroid</h3>
<p>The spectral centroid is the first moment over the indexes weighted by the vector of power spectrum values. It is computed by <b>rta_weighted_moment_1_indexes</b>. The result unit is (of the power spectrum, starting at 0). This function returns also the input sum as it can be used in further calculations.</p>
<p><a class="anchor" id="spread_deviation"></a> </p><h3>4.3.2 Spread and deviation</h3>
<p>The spectral spread is the second central moment over the indexes weighted by the vector of power spectrum values. It is computed by <b>rta_weighted_moment_2_indexes</b>. The result unit is (of the power spectrum, starting at 0).</p>
<p>The standard deviation is .</p>
<p><a class="anchor" id="skewness"></a> </p><h3>4.3.3 Skewness</h3>
<p>The spectral skewness is the third standard central moment over the indexes weighted by the vector of power spectrum values. It is computed by {rta_std_weighted_moment_3_indexes}. The result is without unit. $$ m_{3std} = skewness =  { (i - centroid )^3  input(i)} {std^3  input(i)} $$</p>
<p><a class="anchor" id="kurtosis"></a> </p><h3>4.3.4 Kurtosis</h3>
<p>The spectral kurtosis is the fourth standard central moment over the indexes weighted by the vector of power spectrum values. It is computed by <b>rta_std_weighted_moment_4_indexes</b>. The result is without unit.</p>
<p>Note that the kurtosis is often defined as the fourth cumulant divided by the square root of the variance, which gives $kurtosis =</p>
<p>This function does not include the .</p>
<p><a class="anchor" id="descr_mel_bands"></a> </p><h1>5 Descriptors based on the mel bands</h1>
<p><a class="anchor" id="mel_bands"></a> </p><h2>5.1 Mel bands</h2>
<p><a class="anchor" id="mfcc"></a> </p><h2>5.2 Mel-frequency cepstral coefficients (MFCC)</h2>
<p><a class="anchor" id="delta_delta_mfcc"></a> </p><h2>5.3 Delta and delta-delta MFCC</h2>
<p><a class="anchor" id="style_guide"></a> </p><h1>6 Style guide</h1>
<p><a class="anchor" id="prefix"></a> </p><h2>6.1 Prefix</h2>
<p><a class="anchor" id="declarations_definition"></a> </p><h2>6.2 Declarations and definitions</h2>
<p><a class="anchor" id="headers"></a> </p><h2>6.3 Headers</h2>
<p><a class="anchor" id="real_types"></a> </p><h2>6.4 Real types</h2>
<p><a class="anchor" id="memory_allocation"></a> </p><h2>6.5 Memory allocation</h2>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
