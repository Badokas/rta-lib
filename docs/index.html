<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rta-lib: rta-lib overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rta-lib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">rta-lib overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>WORK IN PROGRESS !!!</h1>
<h1>Table of Contents</h1>
<ul>
<li>1 <a href="#generalities">Generalities</a></li>
<li>2 <a href="#configuration">Library configuration</a></li>
<li>3 <a href="#descr_vector_samples">Descriptors based on a vector of samples</a><ul>
<li>3.1 <a href="#resampling">Re-sampling</a></li>
<li>3.2 <a href="#yin">Yin</a></li>
<li>3.3 <a href="#gain_integer_float">Gain and integer-float conversion</a></li>
<li>3.4 <a href="#pre_emphasis">Pre-emphasis</a></li>
<li>3.5 <a href="#windowing">Windowing</a></li>
<li>3.6 <a href="#lpc">Linear predictive coefficients (LPC)</a></li>
</ul>
</li>
<li>4 <a href="#descr_power_spectrum">Descriptors based on the power spectrum</a><ul>
<li>4.1 <a href="#real_fourier_transform">Real Fourier transform</a></li>
<li>4.2 <a href="#complex_to_power_spectrum">Complex spectrum to power spectrum</a></li>
<li>4.3 <a href="#statistical_moments">Statistical moments</a><ul>
<li>4.3.1 <a href="#centroid">Centroid</a></li>
<li>4.3.2 <a href="#spread_deviation">Spread and deviation</a></li>
<li>4.3.3 <a href="#skewness">Skewness</a></li>
<li>4.3.4 <a href="#kurtosis">Kurtosis</a></li>
</ul>
</li>
</ul>
</li>
<li>5 <a href="#descr_mel_bands">Descriptors based on the mel bands</a><ul>
<li>5.1 <a href="#mel_bands">Mel bands</a></li>
<li>5.2 <a href="#mfcc">Mel-frequency cepstral coefficients (MFCC)</a></li>
<li>5.3 <a href="#delta_delta_mfcc">Delta and delta-delta MFCC</a></li>
</ul>
</li>
<li>6 <a href="#style_guide">Style guide</a><ul>
<li>6.1 <a href="#prefix">Prefix</a></li>
<li>6.2 <a href="#declarations_definitions">Declarations and definitions</a></li>
<li>6.3 <a href="#headers">Headers</a></li>
<li>6.4 <a href="#real_types">Real types</a></li>
<li>6.5 <a href="#memory_allocation">Memory allocation</a></li>
</ul>
</li>
</ul>
<p><a class="anchor" id="generalities"></a> </p><h1>1 Generalities</h1>
<p>The <em>RTA</em> library is frame-based, which means that for any vector of samples, a set of descriptors can be computed without adding any delay. A noticeable exception to this is the <em>delta</em> (and <em>delta-delta</em>) computation, as it is based on more than one frame.</p>
<p>There are two variants of each function, one being post-fixed with <code>_stride</code>. It allows to directly access interleaved data without copying them (like a stereophonic samples vector). However, using a big <em>stride</em> value may lead to a bad usage of the memory cache.</p>
<p>Any index starts at 0.</p>
<p>Some functions require an initialisation before any processing, in order to pre-calculate what will not depend on the incoming frame. Every allocation must be done before anything else, outside of the functions themselves except mentioned otherwise.</p>
<p>Some descriptors can be computed by several functions, and the results may slightly differ for several reasons: the functions do not rely on the same algorithms and the signals used for the computation may differ (due to windowing, filtering, etc.). The auto-correlation from <em>yin</em> and from the <em>LPC</em> are not the same and there is a lot of ways to get the energy: from <em>yin</em>, as the sum of the squares of the samples, from <em>LPC</em>, or as the first <em>MFCC</em> coefficient.</p>
<p><a class="anchor" id="configuration"></a> </p><h1>2 Library configuration</h1>
<p>A file named <code>rta_configuration.h</code> must be present within your sources in order to use the <em>RTA</em> library. It is not included within the <em>RTA</em> source files. An empty file means that the defaults settings are used for the compilation.</p>
<p>Instead of using the <code>malloc</code>, <code>realloc</code> and <code>free</code> functions from the <code>stdlib.h</code>, one can respectively define <code>rta_malloc</code>, <code>rta_realloc</code> and <code>rta_free</code>. (see <a href="#memory_allocation">6.5</a>)</p>
<p>The floating-point precision can be simple, double or long double, according to the definition of <code>RTA_REAL_TYPE</code> to respectively <code>RTA_FLOAT_TYPE</code>, <code>RTA_DOUBLE_TYPE</code> or <code>RTA_LONG_DOUBLE_TYPE</code>. The constants in <code><a class="el" href="rta__float_8h.html" title="rta_real_t type wrapper for &lt;float.h&gt; ">rta_float.h</a></code> are then redefined according to the proper type from <code>float.h</code>. The same applies to the functions in <code><a class="el" href="rta__math_8h.html" title="Mathematical functions, &lt;math.h&gt; for rta_real_t type. ">rta_math.h</a></code> from <code>math.h</code>. (see <a href="#real_types">6.4</a>)</p>
<p>Note that the long double precision is not supported when using Apple's VecLib by setting <code>RTA_USE_VECLIB</code> to 1.</p>
<p><a class="anchor" id="descr_vector_samples"></a> </p><h1>3 Descriptors based on a vector of samples</h1>
<p>The vector of samples is characterised by its sample-rate and its size. Moreover, to use sizes larger than those provided by the sound card (e.g. for <em>Fourier</em> transforms), the hop-size gives the number of samples between two consecutive vectors that overlap if the hop-size is smaller than the vector-size.</p>
<p><a class="anchor" id="resampling"></a> </p><h2>3.1 Re-sampling</h2>
<p>Down-sampling a signal is interesting to lower the further computations, especially for the computational-intensive algorithms, like <em>yin</em>. It can help to concentrate on a range of the spectrum where the information is pertinent for the analysis: the <em>LPC</em> (which is linear, as its name suggests it) finds poles and zeros to fit the whole spectrum; to keep the results under 5 kHz, we simply use a sample-rate of 11 kHz. If the original signal sample-rate is 44 kHz, we can use the function <code>rta_downsample_int_mean</code> with a factor of 4. This function implies a low-pass filtering. The function <code>rta_downsample_int_remove</code> can produce aliasing if the original signal contains information above half of the resulting sample-rate. Note that the resulting samples vector-size is smaller, according to the given factor.</p>
<p><a class="anchor" id="yin"></a> </p><h2>3.2 Yin</h2>
<p>The <em>yin</em> algorithm computes the periodicity of a samples vector, finding its most probable <em>lag</em>. To get the period in Hz, on simply multiply this lag by the input vector sample-rate.</p>
<p>Note that the <em>yin</em> algorithm operates on a non-windowed samples vector. As it can be computational-intensive, a down-sampling of the incoming vector is often performed: to track a pitch below 1 kHz, one can use a sampling-rate of 11 kHz, or even 5.5 kHz, depending on the results quality request. One can then check the <em>absolute minimum</em> found, which gives the <em>periodicity</em> as long as the absolute minimum is positive: </p><p class="formulaDsp">
\[periodicity = 1 - \sqrt {absolute\_minimum}\]
</p>
<p>Before computing anything, a new <em>yin</em> structure must be allocated and filled with the <code>rta_yin_setup_new</code> function. It will be released by the function <code>rta_yin_setup_delete</code>. (The auto-correlation result vector must also be allocated beforehand, like any results vector.)</p>
<p><a class="anchor" id="gain_integer_float"></a> </p><h2>3.3 Gain and integer-float conversion</h2>
<p>The samples are generally coded by floating-points number over 32 bits, within the range [-1.0, 1.0]. To convert them into 16 bits signed integers (which is the format used by some systems, like <em>HTK</em>), one can apply a simple gain of \(2^{15}\) by multiplying every sample.</p>
<p><a class="anchor" id="pre_emphasis"></a> </p><h2>3.4 Pre-emphasis</h2>
<p>The pre-emphasis is a simple first-order difference between the current sample and the previous one (weighted by a factor): \(s(n) = s(n) - f \times s(n-1)\)</p>
<p>It is often used for voice analysis with a factor of 0.97 as it reduces the low frequencies while raising the high frequencies, thus amplifying the contrast.</p>
<p><a class="anchor" id="windowing"></a> </p><h2>3.5 Windowing</h2>
<p>If the samples vector-size is known, it is possible to pre-calculate the weights that will be used to apply a given function. The function <code>rta_window_hamming_weights</code> computes a <em>Hamming</em> window while the function <code>rta_window_hann_weights</code> computes a <em>von Hann</em> window. These (or any weights vector) can be applied with the <code>rta_window_apply</code> function. The functions post-fixed with <code>_in_place</code> change the input samples vector values directly.</p>
<p>If the samples vector-size is not known in advance, one can still apply the window using the <code>rta_window_rounded_apply</code> function. There is no interpolation, then. The weights vector indexes are simply scaled and rounded: this is efficient but the rounding error may be unacceptable if the size of the weights vector is too small comparing with the samples vector size. It is also possible to compute and apply a window on the fly, with the functions <code>rta_window_hann_apply</code> and <code>rta_window_hamming_apply</code>.</p>
<p><a class="anchor" id="lpc"></a> </p><h2>3.6 Linear predictive coefficients (LPC)</h2>
<p>The <code>rta\_lpc</code> function calculates the linear predictive coefficients (<em>LPC</em>) for a samples vector, using an auto-correlation and a <em>Levinson-Durbin</em> decomposition. Note that the <em>LPC</em> order is one value less than the <em>LPC</em> size.</p>
<p>The first <em>LPC</em> coefficient is always 1 and is often replaced (e.g. in <em>HTK</em>) by the prediction error, which gives the energy of the samples vector. If the <em>LPC</em> is computed on overlapping samples vectors, they are often windowed in order for the coefficients to evolve smoothly from frame to frame, and the energy is then reduced (by a constant factor depending on the window).</p>
<p><a class="anchor" id="descr_power_spectrum"></a> </p><h1>4 Descriptors based on the power spectrum</h1>
<p>Some descriptors are based on the power spectrum of a samples vector. The samples vector is first windowed. Then a real <em>Fourier</em> transform is applied, giving a complex spectrum. The power spectrum is the square of the magnitude of the complex spectrum.</p>
<p><a class="anchor" id="real_fourier_transform"></a> </p><h2>4.1 Real Fourier transform</h2>
<p>Before computing a real <em>Fourier</em> transform, a new real <em>Fourier</em> transform setup must be allocated and filled with the <code>rta_fft_real_setup_new</code> function, with the type <code>real_to_complex_1d</code>. It will be released by the function <code>rta_fft_setup_delete</code>. The function <code>rta_fft_execute</code> applies the <em>Fourier</em> transform to a samples vector.</p>
<p>The transform size must be a power of 2. If the transform size is bigger than the actual samples vector, it is then padded with zeros.</p>
<p>By convention (e.g. <em>HTK</em>), no scale is applied to this direct transform. The inverse of the transform size can later be applied to the inverse transform in order to obtain the identity transform.</p>
<p><a class="anchor" id="complex_to_power_spectrum"></a> </p><h2>4.2 Complex spectrum to power spectrum</h2>
<p>The power spectrum is the square of the magnitude the complex spectrum.</p>
<p>Its size is half the size of the <em>Fourier</em> transform plus one (the last element corresponds to the <em>Nyquist</em> frequency). To get a correspondence between the power spectrum index and the corresponding frequency, one can apply a simple ratio between the maximum frequency (which is half of the sample-rate) and the maximum index (which is half of the <em>Fourier</em> transform size, as all the indexes start at 0): </p><p class="formulaDsp">
\[frequency = index \frac {sample\_rate} {transform\_size} \]
</p>
<p><a class="anchor" id="statistical_moments"></a> </p><h2>4.3 Statistical moments</h2>
<p>The statistical moments can be computed from any samples vector, as long as the weights are positive, as they represent the probability of the random variables to appear. The power spectrum conforms to this, as any value is positive, but not the amplitude spectrum (if not translated above 0). The same applies for the moments of the mel bands.</p>
<p>The moments are calculated over the indexes and weighted by the input values. They will be normalised by the sum of the input values in order to get the indexes probability. Note that all moments (but the first) are centred. Any moment above the second can be standardised.</p>
<p>The moments described hereafter describe the power spectrum moments.</p>
<p><a class="anchor" id="centroid"></a> </p><h3>4.3.1 Centroid</h3>
<p>The spectral centroid is the first moment over the indexes weighted by the vector of power spectrum values. It is computed by <code>rta_weighted_moment_1_indexes</code>. The result unit is \(index\) (of the power spectrum, starting at 0). This function returns also the input sum as it can be used in further calculations. </p><p class="formulaDsp">
\[m_1 = centroid = \frac {\sum_i i \times input(i)} {\sum_i input(i)} \]
</p>
<p><a class="anchor" id="spread_deviation"></a> </p><h3>4.3.2 Spread and deviation</h3>
<p>The spectral spread is the second central moment over the indexes weighted by the vector of power spectrum values. It is computed by <code>rta_weighted_moment_2_indexes</code>. The result unit is \(index^2\) (of the power spectrum, starting at 0). </p><p class="formulaDsp">
\[m_2 = spread = \frac {\sum_i (i - centroid )^2 \times input(i)} {\sum_i input(i)} \]
</p>
<p>The standard deviation is \(std = \sqrt {spread}\).</p>
<p><a class="anchor" id="skewness"></a> </p><h3>4.3.3 Skewness</h3>
<p>The spectral skewness is the third standard central moment over the indexes weighted by the vector of power spectrum values. It is computed by <code>rta_std_weighted_moment_3_indexes</code>. The result is without unit. </p><p class="formulaDsp">
\[m_{3std} = skewness = \frac {\sum_i (i - centroid )^3 \times input(i)} {std^3 \sum_i input(i)} \]
</p>
<p><a class="anchor" id="kurtosis"></a> </p><h3>4.3.4 Kurtosis</h3>
<p>The spectral kurtosis is the fourth standard central moment over the indexes weighted by the vector of power spectrum values. It is computed by <code>rta_std_weighted_moment_4_indexes</code>. The result is without unit. </p><p class="formulaDsp">
\[m_{4std} = kurtosis = \frac {\sum_i (i - centroid )^4 \times input(i)} {std^4 \sum_i input(i)} \]
</p>
<p>Note that the kurtosis is often defined as the fourth cumulant divided by the square root of the variance, which gives: </p><p class="formulaDsp">
\[kurtosis = \frac {m_4} {std^4) - 3\]
</p>
<p> This function does not include the <code>"-3"</code> term.</p>
<p><a class="anchor" id="descr_mel_bands"></a> </p><h1>5 Descriptors based on the mel bands</h1>
<p>The mel scale can be derived from the frequencies in hertz. The conversion functions are in <code><a class="el" href="rta__mel_8h.html" title="Mel conversions (HTK and Auditory Toolbox styles) ">rta_mel.h</a></code>. They are based on two slightly different formulas, according to <em>HTK</em> or the <em>Auditory Toolbox</em> with the respective suffix <code>_htk</code> or <code>_slaney</code>.</p>
<p>The power spectrum is integrated into several bands, according again to <em>HTK</em> or the <em>Auditory Toolbox</em>. The integration window peak is 1 for <em>HTK</em>, while the sum of any channel is 1 for the <em>Auditory Toolbox</em>.</p>
<p>In order to reproduce the results of one of these tools, one must obviously choose the desired variant among the whole computation process.</p>
<p><a class="anchor" id="mel_bands"></a> </p><h2>5.1 Mel bands</h2>
<p>The mel bands integration is done in the magnitude ( \(abs\)) or the power ( \(abs^2\)) domain, using respectively the function <code>rta_spectrum_to_bands_abs</code> or <code>rta_spectrum_to_bands_square_abs</code>. This respectively gives \(mel\_bands = weights\_matrix \times spectrum\), or \(mel\_bands = (weights\_matrix \times \sqrt{spectrum})^2\). The latter is the default (for <em>HTK</em> and <em>Auditory Toolbox</em>) but it involves more computation.</p>
<p>The matrix to multiply the power spectrum vector with, in order to obtain the mel bands, must be computed beforehand, using the <code>rta_spectrum_to_mel_bands_weights</code> function.</p>
<p><a class="anchor" id="mfcc"></a> </p><h2>5.2 Mel-frequency cepstral coefficients (MFCC)</h2>
<p>First, the logarithm of the mel bands values is taken. In order to avoid \(log(0)\), one can add a very small value to the mel bands values before taking the log.</p>
<p>Then a cepstrum is computed for the log of the mel spectrum, using a discrete cosine transform <em>DCT</em> of type II. <em>HTK</em> uses an orthogonal but not unitary transform, while the <em>Auditory Toolbox</em> uses an orthogonal and unitary transform. First, a weights matrix is constructed with the function <code>rta_dct_weights</code> and it is then applied to the mel bands vector using the function <code>rta_dct</code>. The coefficients obtained are the <em>MFCC</em>.</p>
<p>The <em>MFCC</em>, as any <em>DCT</em> coefficients, are ordered by the order of importance to model the spectrum. However, one can need to modify them (for visualisation or further processing) using the liftering functions in <code><a class="el" href="rta__lifter_8h.html" title="Cepstral liftering (HTK and Auditory Toolbox styles) ">rta_lifter.h</a></code>. These functions are provided for the <em>HTK</em> or <em>Auditory Toolbox</em> compatibility.</p>
<p><a class="anchor" id="delta_delta_mfcc"></a> </p><h2>5.3 Delta and delta-delta MFCC</h2>
<p>The function <code>rta_delta</code> computes a simple linear slope on a sequence of fixed-rate sampled data (the frames). The <em>delta</em> values correspond to the mid-point frame (which is not used, by the way). <em>It means that the delta values are not those of the last frame</em>. Considering the filter-size, which is the size of the sequence taken into account, the delay (in frames) introduced is half of the filter-size (rounded down as it is always odd).</p>
<p>Note that the <em>HTK</em> <code>DELTAWINDOW</code> variable is not the same as the filter-size (the same applies for the <code>ACCWINDOW</code> variable): </p><p class="formulaDsp">
\[filter\_size = 1 + 2 \times DELTAWINDOW\]
</p>
<p>Beforehand, a matrix of weights to multiply the sequence vector with is constructed by the function <code>rta_delta_weights</code>. A normalisation factor, computed by the function <code>rta_delta_normalization_factor</code> gives <em>delta</em> values, which are independent of the filter-size. The normalisation factor can be applied directly to the weights matrix but the rounding errors may be unacceptable when using the simple floating-point precision.</p>
<p>Applying the <em>delta</em> computation again gives the <em>delta-delta</em> values, <em>adding a new delay of half of the delta-delta filter-size</em>.</p>
<p><a class="anchor" id="style_guide"></a> </p><h1>6 Style guide</h1>
<p><a class="anchor" id="prefix"></a> </p><h2>6.1 Prefix</h2>
<p>Any file, structure, function, type definition, enumeration (enumerator and elements) and pre-compiler definition is prefixed with <code>rta_</code>, <code>RTA_</code>, <code>_rta_</code> or <code>_RTA_</code>. There are two exceptions to this, to respect the common usage:</p><ul>
<li><code>NULL</code> is defined in <code><a class="el" href="rta__stdlib_8h.html" title="Default defines for the rta library. ">rta_stdlib.h</a></code>;</li>
<li>mathematical constants in <code><a class="el" href="rta__math_8h.html" title="Mathematical functions, &lt;math.h&gt; for rta_real_t type. ">rta_math.h</a></code> are prefixed with <code>M_</code>.</li>
</ul>
<p><a class="anchor" id="declarations_definition"></a> </p><h2>6.2 Declarations and definitions</h2>
<p>A minimum number of <code>#define</code> statements is used, to minimise the global effects:</p><ul>
<li>the <code>const</code> keyword is used for values fixed at compilation time;</li>
<li>the <code>inline</code> keyword is used for in-lined functions. Moreover, the <code>static</code> keyword can be used to limit the definitions to a particular file.</li>
</ul>
<p>The pre-compiler definitions are used to provide transparent wrappers for types (see <a href="#real_types">6.4</a>), functions (see <a href="#memory_allocation">6.5</a>) or to prevent multiple inclusions of files (see <a href="#headers">6.3</a>).</p>
<p><a class="anchor" id="headers"></a> </p><h2>6.3 Headers</h2>
<p>Any header prevents multiple inclusions, includes the <code><a class="el" href="rta_8h.html" title="Base header file for rta library. ">rta.h</a></code> header and allows a C++ inclusion. For a file named <code>rta_filename.h</code>, the content begins as: </p><div class="fragment"><div class="line">#ifndef _RTA_FILENAME_H_</div><div class="line">#define _RTA_FILENAME_H_ 1</div><div class="line"></div><div class="line">#include &quot;rta.h&quot;</div><div class="line"></div><div class="line">#ifdef __cplusplus</div><div class="line">extern &quot;C&quot; {</div><div class="line">#endif</div></div><!-- fragment --><p>and it ends as: </p><div class="fragment"><div class="line">#ifdef __cplusplus</div><div class="line">}</div><div class="line">#endif</div><div class="line"></div><div class="line">#endif /* _RTA_FILENAME_H_ */</div></div><!-- fragment --><p> <a class="anchor" id="real_types"></a> </p><h2>6.4 Real types</h2>
<p>Any function within <em>RTA</em> uses the <code>rta_real_t</code> type.</p>
<p><code>rta_real_t</code> is determined at compilation time by a <code>#define</code> (not a <code>typedef</code>) in <code><a class="el" href="rta__types_8h.html" title="rta_real_t type warper for float, double or long double ">rta_types.h</a></code> to ensure a strict <code>float</code> or <code>double</code> replacement. (As a such, <code>rta_real_t</code> can be used with <code>typedef</code> and <code>sizeof</code> expression.) The functions from the standard header <code>math.h</code> are redefined in <code><a class="el" href="rta__math_8h.html" title="Mathematical functions, &lt;math.h&gt; for rta_real_t type. ">rta_math.h</a></code> to provide corresponding functions for the <code>rta_real_t</code> type.</p>
<p>You can define the pre-compiler variable <code>RTA_REAL_TYPE</code> to <code>RTA_FLOAT_TYPE</code>, <code>RTA_DOUBLE_TYPE</code> or <code>RTA_LONG_DOUBLE_TYPE</code> for using respectively <code>float</code>, <code>double</code> or <code>long double</code> type as the effective representation of <code>rta_real_t</code>. Note that the latter is untested. The default is to use <code>RTA_FLOAT_TYPE</code> if <code>RTA_REAL_TYPE</code> is not defined into the user's <code>rta_configuration.h</code>.</p>
<p>The same applies to the <code>rta_complex_t</code> type. You can define the pre-compiler variable <code>RTA_COMPLEX_TYPE</code> to <code>RTA_FLOAT_TYPE</code>, <code>RTA_DOUBLE_TYPE</code> or <code>RTA_LONG_DOUBLE_TYPE</code> for using respectively <code>float complex</code>, <code>double complex</code> or <code>long double complex</code> type as the effective representation of <code>rta_complex_t</code>. Note that the latter is untested. The default is to use the same type as <code>RTA_REAL_TYPE</code> if <code>RTA_COMPLEX_TYPE</code> is not defined into the user's <code>rta_configuration.h</code>.</p>
<p><a class="anchor" id="memory_allocation"></a> </p><h2>6.5 Memory allocation</h2>
<p>The arrays of real values are not allocated within the \ library, as they are manipulable outside of the library. They must be allocated beforehand, as no memory allocation is done during a function's call (except for the followings).</p>
<p>Specific structures are private: they are defined into the <code>*.c</code> files, without the <code>_t</code> suffix. As an example, there is a public declaration of <code>rta_fft_setup_t</code> in <code><a class="el" href="rta__fft_8h.html" title="Fast Fourier Transform. ">rta_fft.h</a></code>: </p><div class="fragment"><div class="line">typedef struct rta_fft_setup rta_fft_setup_t;</div></div><!-- fragment --><p> And in <code>rta_fft.c</code>, there is a private definition of <code>rta_fft_setup</code>, which may depend on the actual implementation.</p>
<p>Two functions are provided for any private structure:</p><ul>
<li>a <code>_setup_new</code> post-fixed function to allocate the structure by using the <code>rta_malloc</code> function;</li>
<li>a <code>_setup_delete</code> post-fixed function to release the structure by using the <code>rta_free</code> function.</li>
</ul>
<p>Any function dealing with memory within <em>RTA</em> uses the functions from <code><a class="el" href="rta__stdlib_8h.html" title="Default defines for the rta library. ">rta_stdlib.h</a></code>. <code>rta_malloc</code>, <code>rta_realloc</code> and <code>rta_free</code> are pre-compiler definitions that can be provided by the user's <code>rta_configuration.h</code>. They must follow the declarations of respectively <code>malloc</code>, <code>realloc</code> and <code>free</code> from the standard <code>stdlib.h</code>, which they are bound to if no user definition is given. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
